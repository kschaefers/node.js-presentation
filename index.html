<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>node.js</title>

        <meta name="description" content="A presentation about node.js">
        <meta name="author" content="Jakob Kneissl & Katrin Schäfers">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/moon.css" id="theme">
        <link rel="stylesheet" href="css/individualAdditons.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName('head')[0].appendChild(link);
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <br><br>
                    <h1>NODE.JS</h1>
                    <h3>Serverseitiges JavaScript</h3>
                    <p>Seminar IM SS2015 - 12.05.2015<br>Katrin Schäfers und Jakob Kneißl</p>
                </section>

                <section>
                    <h2>Agenda</h2>
                    <ol>
                        <li>Einführung, Aufbau und Module</li>
                        <li>Hello World</li>
                        <li>Event Loop</li>
                        <li>Praxisbeispiel</li>
                        <li>Node.js in der Praxis</li>
                        <li>Diskussion</li>
                    </ol>
                    <aside class="notes">
                        Folienzuordnung der Themen:
                        <ul>
                            <li>Einfühung, Aufbau und Module: Folien 3-7</li>
                            <li>Hello World Beispiel: Folien 8-9</li>
                            <li>Event Loop / Eventgetriebene Programmierung: Folien 10-21</li>
                            <li>Praxisbeispiel / Node.js Webserver Beispiel: Folien 22-47</li>
                            <li>Node.js in der Praxis: Folien 48-52</li>
                            <li>Diskussion / Fragen: Folie 53</li>
                        </ul>
                    </aside>
                </section>

                <section>
                    <h2>Lernziele</h2>
                    <h4>Was wir am Ende gelernt haben</h4>
                    <ul>
                        <li>Aufbau von Node.js</li>
                        <li>Eventgetriebene Programmierung</li>
                        <li>Entwicklung eines einfachen Webservers</li>
                        <li>Strukturierung und Organisation von Node.js Code</li>
                    </ul>
                    <aside class="notes">
                        Kapitelzuordnung der Lernziele:
                        <ul>
                            <li>Der Aufbau von Node.js wird behandelt im Kapitel "Einführung, Aufbau und Module".</li>
                            <li>Eventgetriebene Programmierung wird behandelt im Kapitel "Event Loop".</li>
                            <li>Entwicklung eines einfachen Webservers wird behandelt im Kapitel "Praxisbeispiel".</li>
                            <li>Strukturierung und Organisation von Node.js Code wird behandelt in den Kapiteln "Einführung, Aufbau und Module" sowie "Praxisbeispiel".</li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <img src="img/nodejs-light.png" style="width:60%;height:60%"/>
                    <h4>Serverseitiges Javascript</h4>
                    <ul>
                        <li>JavaScript Framework für serverseitige Entwicklung</li>
                        <li>Entwickelt 2009 von Ryan Dahl, finanziert von Joyent</li>
                        <li>Implementiert in C/C++ und JavaScript</li>
                        <li>Verfügbar für Windows, Linux und OS X</li>
                    </ul>
                    <aside class="notes">
                        Einige Zusatzinformationen:
                        <ul>
                            <li>Joyent, Dahls damaliger Arbeitgeber, finanzierte die ursprüngliche Entwicklung von Node.js, wird aber inzwischen für ihren Einfluss auf die Node.js Entwicklung kritisiert.</li>
                            <li>Als Folge der anhaltenden Kritik an der Organisation der Node.js Entwicklung entstand im Dezember 2014 ein schnell wachsender Branch, io.js.</li>
                            <li>Node.js war anfangs nur für Unix Systeme verfügbar, Windows wird erst seit 2011 unterstützt.</li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Hello Node.js<br>auf der Konsole</h2>
                    <pre class="noCodeHighlight">
console.log("Hello Node!")
                    </pre>
                    <pre class="console fragment">
                        <samp>
C:\Users\Katrin\nodeProject>node hello.js
Hello Node!
</samp>
                    </pre>
                    <aside class="notes">
                        <ul>
                            <li>Block 1 zeigt den Inhalt einer minimalen Hello Wold Datei in Node.js. Es handelt sich dabei um Standard JavaScript, dass genauso im Browser lauffähig wäre.</li>
                            <li>Block 2 zeigt den Aufruf von Node.js über den Befehl 'node', der sich nach korrekter Installation von Node.js über ein Terminal ausführen lässt.
                                Es wird die Datei hello.js mit dem in Block 1 gezeigten Text übergeben.
                                Die Ausgabe zeigt, dass der JavaScript Code korrekt ausgeführt, und der gewünschte Text ausgegeben wurde.
                            </li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Node.js - Aufbau</h2>
                    <h4>Kernkomponenten</h4>
                    <img src="img/NodejsArchitektur.png" />
                    <aside class="notes">
                        Das Diagramm zeigt die Komponenten, aus denen Node.js aufgebaut ist:
                        <ul>
                            <li>
                                Das Betriebssystem ist kein Teil von Node.js, bietet aber die notwendigen Schnittstellen zur Kommunikation
                                mit der Hardware, insbesondere mit der Festplatte und dem Netzwerk
                            </li>
                            <li>
                                Die V8 JavaScript Engine ist ein hochperformanter JavaScript Interpreter, der den JavaScript Code des Node.js Servers ausführt.
                                V8 wurde von Google für den Chrome Webbrowser entwickelt und ist dort auch im Einsatz
                            </li>
                            <li>
                                Die libeio Bibliothek bietet Funktionen für asynchrones I/O zu Festplatte, Netzwerk, anderen Prozessen.
                                Intern nutzt die Bibliothek selbst einen Thread Pool, um eine Vielzahl von gleichzeitigen Anfragen verarbeiten zu können
                            </li>
                            <li>
                                Die libuv Bibliothek implementiert die Node.js Event Loop, die den Programmablauf des Servers steuert
                            </li>
                            <li>
                                Als Node.js Bindings wird die Anwendungsschicht bezeichnet, die die darunterliegenden Komponenten miteinander verknüpft.
                                Sie bietet die Schnittstellen zum Zugriff auf die Node.js Funktionalität für die darüberliegenden Schichten.
                            </li>
                            <li>
                                In der Node.js Standard Library finden sich Implementierungen verschiedener Module mit grundlegenden Funktionen, die in Node.js Programme eingebunden werden können.
                                Beispiele hierfür sind das http Modul zur Implementierung eines Webservers und das fs Modul für Zugriff auf das Dateisystem
                            </li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Module in Node.js</h2>
                    <ul>
                        <li>Code wird in Modulen organisiert</li>
                        <li>Node.js Module bieten eine definierte Schnittstelle</li>
                        <li>Module können einfach installiert und eingebunden werden</li>
                        <li>Ziele:
                            <ul>
                                <li>separation of concerns</li>
                                <li>information hiding</li>
                                <li>encapsulation</li>
                                <li>clean code</li>
                            </ul>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Die Schnittstelle von Node.js Modulen wird im Praxisbeispiel näher erläutert, siehe Folie 25</li>
                            <li>Die Installation von externen Node.js Modulen erfolgt über den Node Package Manager npm, siehe dazu auch die folgende Folie</li>
                            <li>Das Einbinden von Node.js Modulen mit der require-Methode wird im Hello World gezeigt, siehe Folie 8</li>
                            <li>Die genannten Ziele der Modularisierung sind aus den Konzepten der objekt-orientierten Programmierung bekannt
                                und dienen analog auch hier der sauberen und wartbaren Sturkturierung von Code</li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Module in Node.js</h2>
                    <h4>Modulquellen</h4>
                    <ul>
                        <li>Vorinstallierte Basismodule (http, fs)</li>
                        <li>Über Node Package Manager npm (express, socket.io)</li>
                        <li>Lokal erstellt</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Vorinstallierte Module sind die Module der Node.js Standard Library, siehe Folie 5</li>
                            <li>Der Node Package Manager (npm) bietet einfache Möglichkeiten, sowohl Module anderer Entwickler herunterzuladen, als auch eigene Module zu veröffentlichen</li>
                            <li>Ein zentrales Repository ermöglicht das Finden und Herunterladen von Modulen mit npm</li>
                            <li>Die Nutzung lokal erstellter Module wird im Praxisbeispiel gezeigt, siehe Folie 26 </li>
                        </ul>
                    </aside>
                </section>

                <section class="example">
                    <h2>"Hello World"<br>in Node.js</h2>
                    <pre class="noCodeHighlight" style="width:95%">
<code>var http = require("http");






</code>
<code class="fragment current-visible" style="margin-top:-185px">http.createServer(



 ).listen(8888);</code>
<code class="fragment" style="margin-top:-191px">http.createServer(function(request, response) {
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
}).listen(8888);</code>
                    </pre>
                    <aside class="notes">
                        <ol>
                            <li>Einbinden des Moduls "http", welches eine einfache WebService Funktionalität zur Verfügung stellt.</li>
                            <li>Erstellen eines WebServers mit Hilfe des Moduls (createServer), welcher auf Port 8888 auf Anfragen wartet.</li>
                            <li>createServer bekommt eine anonyme Funktion übergeben. Diese fungiert als callback-Methode, die aufgerufen wird sobald ein Request eintrifft.</li>
                        </ol>
                    </aside>
                </section>

                <section class="example">
                    <h2>Ausgabe im Browser</h2>
                    <div class="browser">
                        <div class="url">http://localhost:8888/</div>
                        <iframe src="http://localhost:8888/helloWorld" width="750" height="450"></iframe>
                    </div>
                    <aside class="notes">
                        Ausgabe im Browser beim Aufruf des Hello World Beispiels von der vorherigen Folie
                    </aside>
                </section>

                <section class="theory">
                    <h2>Eventgetriebene<br>Programmierung in Node.js</h2>
                    <h4>Performanceprobleme</h4>
                    <ul>
                        <li>I/O dauert meistens am längsten</li>
                        <li>Wartezeiten für I/O müssen minimiert werden</li>
                    </ul>
                    <h4 style="margin-top: 20px">Node.js Lösung</h4>
                    <ul>
                        <li>I/O läuft immer asynchron... </li>
                        <li>... durch eventgetriebene Programmierung</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>I/O Operationen (Lesen und Schreiben von Daten) ist meistens sehr viel zeitaufwändiger als reine CPU Berechnungen</li>
                            <li>Durch die langsame Verarbeitung von Daten bei der Kommunikation mit z.B. der Festplatte oder dem Netzwerk entstehen lange Wartezeiten</li>
                            <li>Ziel von Node.js ist es, diese Wartezeiten zu minimieren bzw. den Prozessor während des Wartens effizienter zu nutzen.</li>
                            <li>Node.js verarbeitet I/O Aufgaben immer asynchron, um den ausführenden Thread nicht mit den Wartezeiten eines synchronen Aufrufs zu belegen</li>
                            <li>Das eventgetriebene Modell von Node.js ermöglicht die effiziente Verwaltung der asynchronen internen Abläufe</li>
                            <li>Die genaue Funktionsweise und Implementierung ist im folgenden Kapitel beschrieben</li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Eventgetriebene<br>Programmierung in Node.js</h2>
                    <h4>Funktionsweise</h4>
                    <ul>
                        <li>Der Programmablauf wird durch Events gesteuert</li>
                        <li>Definierte Trigger lösen Events aus</li>
                        <li>Ausgelöste Events werden in einer Queue abgelegt</li>
                        <li>Ein Thread, die Event Loop, verarbeitet alle Events in der Queue </li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Anwendungslogik wird in Node.js durch Events gesteuert</li>
                            <li>Events werden als JavaScript Funktionen implementiert und als Callback Funktionen an Triggern (Auslösern) registriert</li>
                            <li>Ein Trigger ist z.B. der Port Listener des Node.js Webservers</li>
                            <li>Beim Auslösen eines Events können der Callback Funktion eventspezifische Parameter übergeben werden, siehe dazu auch Folie 17</li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Ablauf</h4>
                    <img src="img/eventloop.png" />
                    <aside class="notes">
                        Die abgebildete Grafik zeigt einen Überblick über den eventgetriebenen Programmablauf in Node.js,
                        der auf den kommenden Folien im Detail erklärt wird.
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Beispiel - Schritt 1</h4>
                    <pre class="noCodeHighlight" style="width: 95%">
<code>
http.createServer(function(request, response) {
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
}).listen(8888);
</code>
                    </pre>
                    Callback Funktion wird am HTTP Server registriert
                    <aside class="notes">
                        Der gezeigte Code entspricht dem Hello World Beispiel, dass bereits auf Folie 8 gezeigt wurde.
                        <ul>
                            <li>Eine anonyme Funktion wird deklariert und als Callback an die createServer-Methode übergeben</li>
                            <li>Die Funktion erhält zwei Übergabeparameter, die beim Auftreten des Events vom Auslöser bereitgestellt werden</li>
                            <li>Der Auslöser, das http Modul, löst bei eingehenden HTTP Requests auf dem angegebenen Port 8888 ein Event aus</li>
                            <li>Das ausgelöste Event enthält den definierten Callback und die bereitgestellten Übergabeparameter und wird in der Queue abgelegt</li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Beispiel - Schritt 2</h4>
                    <div class="browser" style="height: 50px; width: 750px; background:url('css/img/browser.png') no-repeat scroll rgba(0, 0, 0, 0);margin-left: 50%;transform: translateX(-50%);">
                        <div class="url">http://localhost:8888/</div>
                    </div>
                    Client Request erreicht den Node Server
                    <aside class="notes">
                        Nachdem die Callback Methode registriert wurde, wird jetzt ein Request durch den Aufruf der gezeigten URL im Browser ausgelöst.
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Beispiel - Schritt 3</h4>
                    <img src="img/eventloop2.png" />
                    <div>Request wird als Event in die Queue eingetragen</div>
                    <aside class="notes">
                        Der weiße Pfeil zeigt den Datenfluss von der Netzwerkschnittstelle im http Modul zur Event Queue, wo das erzeugte Event abgelegt wird.
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Beispiel - Schritt 4</h4>
                    <img src="img/eventloop3.png" />
                    <div>Event Loop führt das Event aus</div>
                    <aside class="notes">
                        <ul>
                            <li>Nachdem alle in der Queue vorgelagerten Events verarbeitet wurden, wird nun das http Event von der Event Loop aufgerufen.</li>
                            <li>Das Event wird ausgeführt, indem die Callback Methode mit den bereitgestellten Übergabeparametern aufgerufen wird.</li>
                            <li>
                                Die Event Loop besteht pro Node.js Instanz aus nur einem Thread, das heißt, nachfolgende Events können erst verarbeitet werden,
                                wenn die gesammte Callback Methode des aktuellen Events durchlaufen wurde.
                            </li>
                            <li>Es ist darum sehr wichtig, die Ausführungszeit der Callback Methode möglichst kurz zu halten.</li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Beispiel - Schritt 4</h4>
                    <pre class="noCodeHighlight" style="margin:0;width:95%;">
<code>
function(request, response) {
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
}
</code>
                    </pre>
                    <ul>
                        <li>Event Code: auf den Request registrierter Callback</li>
                        <li>Callback Parameter wurden durch den Event Auslöser gesetzt</li>
                    </ul>
                    <aside class="notes">
                        Der Codeblock zeigt die zuvor registrierte Callback Funktion, die nun ausgeführt wird.
                        Die Funktion sollte keine rechenintensiven Aufgaben ausführen, in diesem Fall wird nur
                        der Rückgabewert des HTTP Requests geschrieben.
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Beispiel - Schritt 5</h4>
                    <img src="img/eventloop4.png" />
                    <p align="left">
                        Event wird fertig bearbeitet<br>
                        Optional: I/O Jobs werden deligiert, Callback wird gesetzt
                    </p>
                    <aside class="notes">
                        Im gezeigten Beispielcode ist der Request an dieser Stelle fertig bearbeitet.<br>
                        In vielen Fällen müssen aber die Daten für die Response erst mit Hilfe von I/O Operationen ermittelt werden.
                        Beispiele hierfür sind
                        <ul>
                            <li>Lesen oder Schreiben von Dateien im Dateisystem</li>
                            <li>Lesen oder Schreiben in/aus einer Datenbank</li>
                            <li>Kommunikation mit einem anderen Server</li>
                        </ul>
                        In diesen Fällen muss in der nun aktiven Callback Methode eine weiterer Callback für den neuen asynchronen Aufruf registriert werden.
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Beispiel - Schritt 6</h4>
                    <img src="img/eventloop5.png" />
                    <div>Ergebnis Event mit Callback wird in die Queue eingetragen</div>
                    <aside class="notes">
                        Nachdem der asynchrone Aufruf abgeschlossen wurde, wird auch dessen Ergebnis wieder in Form eines Events in der Queue gespeichert.
                        Je nach implementierter Logik können auch in diesem Event wieder neue asynchrone Aufrufe gestartet werden.
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Technische Sicht - Reactor Pattern</h4>
                    <img src="img/ReactorPattern.png" />
                    <p>In Node.js in der Bibliothek libuv implementiert</p>
                    <aside class="notes">
                        Das abgebildete UML Diagramm zeigt eine vereinfachte Modellierung des Reactor Patterns,
                        welches das Grundprinzip der zuvor gezeigten Datenverarbeitung beschreibt: <br>
                        <ul>
                            <li>Ein Dispatcher sammelt alle anfallenden Aufgaben in einer Queue</li>
                            <li>Der Reactor ruft sequenziell Events vom Dispatcher ab</li>
                            <li>Der Reactor delegiert die Verarbeitung von Events an Handler, die die entsprechenden Events ausführen</li>
                        </ul>
                    </aside>
                </section>

                <section class="theory">
                    <h2>Event Loop in Node.js</h2>
                    <h4>Die wichtigen Unterschiede</h4>
                    <table>
                        <tr><th><h5>Sequenziell</h5></th><th><h5>Eventgetrieben mit Node.js</h5></th></tr>
                        <tr><td>Programmsteuerung durch sequenziellen Code</td><td>Programmsteuerung durch Events</td></tr>
                        <tr><td>Ein Thread pro Request</td><td>Ein Thread für alle Requests</td></tr>
                        <tr><td>Nebenläufigkeit wird explizit implementiert</td><td>Nebenläufigkeit durch Framework gesteuert</td></tr>
                    </table>
                    <aside class="notes">
                        Die wichtigsten Unterschiede zwischen dem in vielen Webserver Lösungen wie PHP oder JavaEE implementierten seqenziellen Programmablauf
                        und dem eventgetriebenen Ansatz von Node.js werden hier zusammengefasst:
                        <ul>
                            <li>Der Programmierstil unterscheidet sich durch einen anderen Programmaufbau, da nicht sequenzieller Code sondern einzelne Events den Programmablauf steuern.
                                Dies führt unter anderem zu einer anderen Design von Schnittstellen und einer anderen Strukturierung des Quellcodes
                            </li>
                            <li>Webserver mit sequenziellem Programmablauf reservieren für jeden eingehenden Request einen Thread,
                                der wieder freigegeben wird, sobald der Request fertig bearbeitet wurde. Diese Lösung skaliert nur sehr begrenzt mit der der Anzahl der gleichzeitig eingehenden Requests.
                                Die in Node.js implementierte Event Loop bearbeitet als einzelner Thread alle eingehenden Requests. Dieser Ansatz setzt eine sehr schnelle Verarbeitung einzelner Requests
                                voraus, was durch die asynchrone Verarbeitung von langlaufenden Aufgaben sichergestellt werden soll.
                            </li>
                            <li>
                                Nebenläufigkeit (asynchrone Programmabläufe) werden in Node.js nicht explizit implementiert,
                                da da Node.js (in der Regel) die Verwaltung aller asynchronen Aufgaben kapselt und dem Entwickler nur die Implementierung der Events überlässt.
                                Allerdings muss auch in Node.js, etwa beim synchronisieren der Ergebnisse mehrerer paralleler asynchroner Aufrufe ein gewisser Aufwand getrieben werden.
                            </li>
                        </ul>
                    </aside>
                </section>
                <section class="example">
                    <h2>Praxisbeispiel - Ziele</h2>
                    <ul>
                        <li>Bedienung durch Browser</li>
                        <li>Texteingabefeld</li>
                        <li>Weiterleitung</li>
                        <li>Anzeige des eingegebenen Textes</li>
                    </ul>
                    <aside class="notes">
                        Im Praxisbeispiel wird eine kleine Node-Applikation entwickelt:
                        <ul>
                            <li>Diese soll durch den Browser bedienbar sein.</li>
                            <li>Auf der Startseite soll die Möglichkeit einer Texteingabe zur Verfügung stehen.</li>
                            <li>Nach einer erfolgten Texteingabe soll der Anwender auf die zweite Seite weitergeleitet werden und der zuvor eingegebene Text soll angezeigt werden.</li>
                        </ul>
                    </aside>
                </section>

                <section class="example">
                    <h2>Komponenten</h2>
                    <img src="./img/komponentenV4.png" alt="Komponenten">
                    <aside class="notes">
                        Für die kleine Beispiel-Node-Applikation werden verschiedene Komponenten entwickelt, welche unterschiedliche Aufgaben haben:
                        <ul>
                            <li>WebServer: Bereitstellen von dynamische Webseiten, Entgegennehmen der Requests vom Client</li>
                            <li>Router: Delegieren der Requests an den richtigen Request Handler je nach aufgerufener URL</li>
                            <li>Request Handler: Bearbeiten des Requests und senden der Response an den Client</li>
                        </ul>
                        Für das hier entwickelte Beispiel wären diese vielen Komponenten nicht unbedingt notwendig, doch sie sollen verdeutlichen, wie die Entwicklung und Modularisierung aussehen könnte, wenn man mit Node.js ein größeres Projekt entwickeln möchte.
                    </aside>
                </section>

                <section class="example">
                    <h2>WebService als Modul (V1)</h2>
                    <img src="./img/komponentenV1.png" alt="Komponenten">
                    <aside class="notes">
                        <p>In der ersten Version des Praxisbeispiels wird erst einmal der WebService entwickelt und in ein Modul ausgegliedert.</p>
                        <p>Das Hello World Beispiel von Folie 8 dient hier als Grundlage.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Server-Modul (V1)</h2>
                    <pre class="noCodeHighlight" style="width: 100%;overflow: hidden;">
var http = require("http");

<kbd>function start() {
    function onRequest(request, response) {</kbd>
        response.writeHead(200, {"Content-Type": "text/plain"});
        response.write("Hello World");
        response.end();
    <kbd>}</kbd>

    http.createServer(<kbd>onRequest</kbd>).listen(8888);
<kbd>}</kbd>

<kbd>exports.start = start;</kbd>
                    </pre>
                    <aside class="notes">
                        <p>Die farbigen Markierungen verdeutlichen die Änderungen gegenüber dem auf Folie 8 gezeigten Hello World Beispiel. Auch in den folgenden Folien verdeutlichen die farbigen Markierungen immer die Änderungen im Vergleich zur vorherigen Version.</p>
                        <ul>
                            <li>Die anonyme Callback-Methode wird ausgegliedert in die Methode <i>onRequest()</i>. Beim Start des Servers wird nur noch die Referenz auf die Callback-Methode übergeben.</li>
                            <li>Bis auf die Einbindung des Moduls <i>http</i> wird der Code in die Methode <i>start()</i> gepackt.</li>
                            <li>Die Methode <i>start()</i> wird nach nach außen (außerhalb des Server-Moduls) sichtbar gemacht: <i>exports.start = start</i><br>(Beim Aufruf der Methode <i>start()</i> auf dem Modul wird innerhalb des Moduls die Methode <i>start()</i> aufgerufen.)</li>
                        </ul>
                    </aside>
                </section>

                <section class="example">
                    <h2>index.js (V1)</h2>
                    <pre class="noCodeHighlight">
<kbd>
var server = require("./server");

server.start();
</kbd>
                    </pre>
                    <aside class="notes">
                        <p>index.js bindet nun das Server-Modul ein, welches auf der selben Ebene liegt. Anschließend wird auf dem WebServer die Methode <i>start()</i> aufgerufen.</p>
                        <p>Gegenüber dem Hello World Beispiel hat in Version 1 des Praxisbeispiels keine funktionale Änderung stattgefunden. Die der WebServer wurde lediglich als Modul ausgegliedert.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Ausgabe im Browser (V1)</h2>
                    <div class="browser">
                        <div class="url">http://localhost:8888/v1</div>
                        <iframe src="http://localhost:8888/v1" width="750" height="450"></iframe>
                    </div>
                    <aside class="notes">
                        Da keine funktionale Änderung zum Hello World Beispiel stattgefunden hat, ist im Browser keine Veränderung zu sehen.
                    </aside>
                </section>

                <section class="example">
                    <h2>Router hinzufügen (V2)</h2>
                    <img src="./img/komponentenV2.png" alt="Komponenten">
                    <aside class="notes">
                        <p>In der Weiterentwicklung wird nun das Router-Modul hinzugefügt. Da der Router in diesem Schritt jedoch noch keine Funktionalität hat, wird er in der Grafik noch leicht ausgegraut dargestellt.</p>
                        Zukünftige Funktionalität des Routers wird sein:
                        <ul>
                            <li>GET / POST Parameter auslesen</li>
                            <li>Requests an die dazugehörigen Request Handler weiterleiten, abhängig von der aufgerufenen URL</li>
                        </ul>
                    </aside>
                </section>

                <section class="example">
                    <h2>Router-Modul (V2)</h2>
                    <pre class="noCodeHighlight" style="width:95%">
<kbd>
function route(pathname) {
    console.log("About to route a request for " + pathname);
}

exports.route = route;
</kbd>
                    </pre>
                    <aside class="notes">
                        <p>Router-Modul wird mit der Funktion <i>route()</i> hinzugefügt. Diese Funktion ist jedoch erst einmal ohne Funktionalität und macht nur eine Ausgabe auf der Konsole.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>index.js (V2)</h2>
                    <pre class="noCodeHighlight">
var server = require("./server");
<kbd>var router = require("./router");</kbd>

server.start(<kbd>router.route</kbd>);
                    </pre>
                    <aside class="notes">
                        <p>index.js bindet nun zusätzlich zum WebServer auch den Router ein und übergibt die <i>route()</i> Methode an den Server, damit dieser sie aufrufen kann.</p>
                        <p>Da die Kopplung so gering wie möglich gehalten werden soll, wird der Router an dieser Stelle geladen und nicht im WebServer. Auf diese Weise kann der Router ausgetauscht werden, ohne dass der WebServer etwas davon merkt. Solange er eine Methode übergeben bekommt, welche er zum Routen aufrufen kann, ist die genaue Implementierung des Routers egal.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Server-Modul (V2)</h2>
                    <pre class="noCodeHighlight" style="overflow:hidden;width:100%">
var http = require("http");
<kbd>var url = require("url");</kbd>

function start(<kbd>route</kbd>) {
    function onRequest(request, response) {
        <kbd>var pathname = url.parse(request.url).pathname;
        route(pathname);</kbd>
        response.writeHead(200, {"Content-Type": "text/plain"});
        response.write("Hello World");
        response.end();
    }
    http.createServer(onRequest).listen(8888);
}
exports.start = start;                         
                    </pre>
                    <aside class="notes">
                        <p>Im WebServer wird nun zusätzlich das Modul <i>url</i> eingebunden, damit die URL leichter geparst werden kann. Dadurch muss die URL an dieser Stelle nicht händisch geparst werden, sondern das Modul übernimmt diesen Teil.</p>
                        <p>Anschließend wird die <i>route()</i> Methode aufgerufen und der zuvor geparste Pfadname mit übergeben.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Ausgabe im Browser (V2)</h2>
                    <div class="browser">
                        <div class="url">http://localhost:8888/v2</div>
                        <iframe src="http://localhost:8888/v2" width="750" height="450"></iframe>
                    </div>
                    <aside class="notes">
                        Da auch in dieser Version nur das Router-Modul ohne nennenswerte Funktionalität hinzugefügt wurde, hat sich weiterhin an der Ausgabe auf dem Browser nichts verändert.
                    </aside>
                </section>

                <section class="example">
                    <h2>Ausgabe auf der <br>Konsole (V2)</h2>
                    <pre class="console">
<samp>
C:\Users\Katrin\nodeProject>node index.js
About to route a request for /
</samp>
                    </pre>
                    <aside class="notes">
                        Die Konsole bestätigt jedoch, dass im Hintergrund der Pfadname zum Router durchgereicht wurde.
                    </aside>
                </section>

                <section class="example">
                    <h2>Request Handler<br>einfügen (V3)</h2>
                    <img src="./img/komponentenV3.png" alt="Komponenten">
                    <aside class="notes">
                        <p>In der dritten Version bekommt der Router nun Funktionalität und die Request Handler-Modul wird initialisiert.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Request Handler-Modul<br>(V3)</h2>
                    <pre class="noCodeHighlight">
<kbd>function start() {
    console.log("Request handler 'start' was called.");
}

function upload() {
    console.log("Request handler 'upload' was called.");
}

exports.start = start;
exports.upload = upload;</kbd>
                    </pre>
                    <aside class="notes">
                        Im Request Handler-Modul werden zwei Methoden initialisiert:
                        <ul>
                            <li><i>start()</i> für die Funktionalität auf der Startseite</li>
                            <li><i>upload()</i> für die Funktionalität nach der Eingabe (Upload) eines Textes</li>
                        </ul>
                        <p>Anschließend werden diese beiden Methoden nach außen hin sichtbar gemacht, sodass der Request Handler als Modul eingebunden werden kann.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>index.js (V3)</h2>
                    <pre class="noCodeHighlight">
var server = require("./server");
var router = require("./router");
<kbd>var requestHandlers = require("./requestHandlers");</kbd>

<kbd>var handle = {};
handle["/"] = requestHandlers.start;
handle["/start"] = requestHandlers.start;
handle["/upload"] = requestHandlers.upload;</kbd>

server.start(router.route, <kbd>handle</kbd>);
                    </pre>
                    <aside class="notes">
                        <p>In der index.js wird das neue Request Handler-Modul nun eingebunden.</p>
                        <p>Zusätzlich wird ein Array erstellt, in welchem definiert wird, bei welchem Pfadnamen welcher Request Handler zuständig ist. Diese Zuordnung könnte auch an anderen Stellen erfolgen. Aufgrund der möglichst gering zu haltenden Kopplung hat man sich hier jedoch für diese Variante entschieden. Nun muss nämlich nur noch das Array über den Server an den Router weitergegeben werden. Dem Router ist dann völlig egal, welcher Request Handler hinter welchem Pfadnamen steckt, solange die Zuordnung im <i>handle</i>-Array definiert wurde.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Server-Modul (V3)</h2>
                    <pre class="noCodeHighlight" style="overflow:hidden;">
var http = require("http");
var url = require("url");

function start(route, <kbd>handle</kbd>) {
    function onRequest(request, response) {
        var pathname = url.parse(request.url).pathname;

        route(<kbd>handle</kbd>, pathname);

        response.writeHead(200, {"Content-Type": "text/plain"});
        response.write("Hello World");
        response.end();
    }
    http.createServer(onRequest).listen(8888);
}
exports.start = start;                         
                    </pre>
                    <aside class="notes">
                        Der WebServer erhält beim Starten das <i>handle</i>-Array und reicht dies einfach nur an den Router weiter.
                    </aside>
                </section>

                <section class="example">
                    <h2>Router-Modul (V3)</h2>
                    <pre class="noCodeHighlight" style="width:100%">
function route(<kbd>handle</kbd>, pathname) {

    <kbd>if (handle[pathname] === 'function') {
        handle[pathname]();
    } else {
        console.log("No request handler found for " + pathname);
    }</kbd>

}

exports.route = route;
                    </pre>
                    <aside class="notes">
                        Der Router erhält nun Funktionalität:
                        <p>Verweist das <i>handle</i>-Array mit dem Pfadnamen als Key auf eine Funktion, so wird diese aufgerufen. Ist der Eintrag im Array mit dem Pfadnamen als Key nicht vorhanden oder der Eintrag verweist nicht auf eine Funktion, so ist kein passender Request Handler definiert. Dies wird dann über eine entsprechende Ausgabe auf der Konsole festgehalten.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Ausgabe im Browser (V3)</h2>
                    <div class="browser">
                        <div class="url">http://localhost:8888/v3</div>
                        <iframe src="http://localhost:8888/v3" width="750" height="450"></iframe>
                    </div>
                    <aside class="notes">
                        <p>Da auch in dieser Version die Response immer noch nicht verändert wurde, ist im Browser noch keine Änderung im Vergleich zu den vorherigen Versionen zu sehen.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Ausgabe auf der<br>Konsole (V3)</h2>
                    <pre class="console">
<samp>
C:\Users\Katrin\nodeProject>node index.js
Request handler 'start' was called.
</samp>
                    </pre>
                    <aside class="notes">
                        <p>Die Konsole bestätigt jedoch, dass im Hintergrund der Request an den richtigen Request Handler durchgereicht wurde.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Wer antwortet auf den<br>Request?</h2>
                    <img src="./img/komponentenSoNicht.png" alt="Komponenten" class="fragment fade-out" data-fragment-index="1">
                    <img src="./img/komponentenSoNichtMitKreuz.png" alt="Komponenten" class="fragment" style="margin-top: -526px;margin-left: -134px;" data-fragment-index="1">
                    <aside class="notes">
                        <p>Problem bei blockierenden Funktionen allgemein:<br>Die Abarbeitung einer blockierenden Funktion blockiert den gesamten Server und weitere ankommende Requests können nicht gleichzeiig abgearbeitet werden.</p>
                        <p>Probleme bei nicht blockierenden Funktionen:<br>Oft werden Daten im Hintergrund abgerufen und durch eine Callback-Funktion das Ergebnis übermittelt. Würde hier jedoch der WebServer die Response senden, würde im Request Handler der Return-Wert in den meisten Fällen vor dem Aufruf der Callback-Funktion einer asynchronen Abarbeitung gesendet werden. Der WebServer erhält dann einen leeren Return-Wert und kann dem User nicht die richtige Response senden.</p>
                        <p>Aufgrund dieser Probleme ist es an dieser Stelle das Beste, jeden Request Handler für sich selbst die Response senden zu lassen, sobald die Funktion soweit ist.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Request Handler<br>Funkionalität geben (V4)</h2>
                    <img src="./img/komponentenV4.png" alt="Komponenten">
                    <aside class="notes">
                        <p>In der letzten Version dieses Beispiels wird den Request Handlern noch Funktionalität verliehen.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Server-Modul (V4)</h2>
                    <pre class="noCodeHighlight" style="overflow:hidden;width: 98%;max-height: 520px;">
var http = require("http");      var url = require("url");

function start(route, handle) {
    function onRequest(request, response) {
        <kbd>var postData = "";</kbd>
        var pathname = url.parse(request.url).pathname;
        <kbd>request.setEncoding("utf8");
        request.addListener("data", function (postDataChunk) {
            postData += postDataChunk;
        });
        request.addListener("end", function () {</kbd>
            route(handle, pathname, <kbd>response, postData</kbd>);
        <kbd>});</kbd>
    }
    http.createServer(onRequest).listen(8888);
}
exports.start = start;                         
                    </pre>
                    <aside class="notes">
                        <p>Der WebServer antwortet nun nicht mehr selbst auf den Request.</p>
                        Zusätzlich wurden Event Listener für den Request hinzugefügt:
                        <ul>
                            <li><i>data</i>: Durch einen Request empfangene POST-Daten werden auf dem Server in der Variable <i>postData</i> gespeichert.</li>
                            <li><i>end</i>: Sobald der Request beendet wurde, wird die Routing-Methode des Routers aufgerufen. Dieser wird nun zusätzlich noch das Response-Objekt und die in der Variable <i>postData</i> gespeicherten Daten übergeben.</li>
                        </ul>
                    </aside>
                </section>

                <section class="example">
                    <h2>Router-Modul (V4)</h2>
                    <pre class="noCodeHighlight" style="width:100%">
function route(handle, pathname, response, postData) {

    if (typeof handle[pathname] === 'function') {
        handle[pathname](<kbd>response, postData</kbd>);
    } else {
        <kbd>response.writeHead(404, {"Content-Type": "text/plain"});
        response.write("404 Not found");
        response.end();</kbd>
    }
}
exports.route = route;
                    </pre>
                    <aside class="notes">
                        <p>Das Response-Objekt und <i>postData</i> wird an dieser Stelle dem Request Handler weiter gegeben.</p>
                        <p>Sollte kein Request Handler für den aktuellen Pfadnamen gefunden worden sein, antwortet der Router selbst und sendet <i>404</i> als Indikator für eine nicht gefundene Seite zurück.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Request Handler-Modul (V4)</h2>
                    <h3>Teil 1</h3>
                    <pre class="noCodeHighlight" style="overflow:hidden;width:109%;margin-left:-6%;">
function start(response, <kbd>postData</kbd>) {
    <kbd>var body = '&lt;html&gt; &lt;head&gt;' +
            '&lt;meta http-equiv="Content-Type" content="text/html; ' +
            'charset=UTF-8" /&gt; &lt;/head&gt; &lt;body&gt;' +
            '&lt;form action="/upload" method="post"&gt;' +
            '&lt;textarea name="text" rows="10" cols="30"&gt;&lt;/textarea&gt;' +
            '&lt;input type="submit" value="Submit text" /&gt;' +
            '&lt;/form&gt; &lt;/body&gt; &lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();</kbd>
}
                    </pre>
                    <aside class="notes">
                        <p>Im ersten Teil des Request Handlers wird die Funktionalität für die Methode <i>start()</i> hinzugefügt. Hier wird nun eine HTML-Seite mit einem Eingabefeld für eine Texteingabe und einem Submit-Button danach erstellt und über den Request an den Browser zurück geliefert.</p>
                        <p><i>postData</i> wird an dieser Stelle nicht benötigt.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Request Handler-Modul (V4)</h2>
                    <h3>Teil 2</h3>
                    <pre class="noCodeHighlight" style="overflow:hidden;width:111%;margin-left:-7%;">
<kbd>var querystring = require("querystring");</kbd>

function upload(response, <kbd>postData</kbd>) {
    console.log("requestHandler: Request handler 'upload' was called.");

    <kbd>response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("You've sent the text:\n" +
                          querystring.parse(postData).text);
    response.end();</kbd>
}

exports.start = start;
exports.upload = upload;
                    </pre>
                    <aside class="notes">
                        <p>Im zeiten Teil des Request Handlers wird der Methode <i>upload</i> Funktionaliät hinzugefügt. Dem Browser wird der Text <i>You've sent the text:</i> mit einem Zeilenumbruch am Ende zurück gegeben. Zusätzlich wird der auf der vorherigen Seite eingegebene Text angehängt.</p>
                    </aside>
                </section>

                <section class="example">
                    <h2>Ausgabe im Browser (V4)</h2>
                    <div class="browser">
                        <div class="url">http://localhost:8888/v4</div>
                        <iframe src="http://localhost:8888/v4" width="750" height="450"></iframe>
                    </div>
                    <aside class="notes">
                        <p>Im Browser ist nun endlich eine Veränderung zu sehen, da hier jetzt ein Text eingegeben werden kann.</p>
                        <p>Beim Klick auf den Button <i>Submit</i> wird auf die Seite http://localhost:8888/v4/upload weitergeleitet und der eingegebene Text per POST-Methode an den Server übermittelt. Dieser kann den Text dann auf der nächsten Seite anzeigen.</p>
                    </aside>
                </section>

                <section>
                    <h2>Node.js in der Praxis</h2>
                    <h4>Aktueller Stand</h4>
                    <ul>
                        <li>junges, dynamisches Projekt</li>
                        <li>große Community</li>
                        <li>teilweise noch unausgereifte Module</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Node.js wurde erst 2009 entwickelt, und kann daher noch nicht als so ausgereift wie ältere Softwareprojekte angesehen werden</li>
                            <li>Auch die zukünftige Entwicklung des Projekts ist nicht zuletzt durch den entstandenen Branch io.js (siehe auch Annotationen zu Folie 3) nicht zuverlässig vorhersagbar</li>
                            <li>Node.js verfügt über eine große Community; eine Vielzahl an Projekten und Modulen ermöglichen die Umsetzung verschiedenster Projekte </li>
                            <li>Problematisch ist die teilweise noch unvollständige und unausgereifte Implementierung von wichtigen Modulen wie z.B. Schnittstellen zu vielen SQL-Datenbanken.
                                Dieser Missstand ist derzeit noch ein entscheidender Nachteil von Node.js</li>
                        </ul>
                    </aside>
                </section>

                <section>
                    <h2>Node.js in der Praxis</h2>
                    <h4>Tests und Code Qualität</h4>
                    <ul>
                        <li>Entwicklung: Plugins für gängige Entwicklungstools</li>
                        <li>Unittests: Mocha</li>
                        <li>Mocking: Sinon JS, Nock</li>
                        <li>Coverage: Istanbul</li>
                        <li>Statische Analyse: JSHint, JSCS</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Die bekannten IDEs Eclipse, IntelliJ und Netbeans bieten jeweils über Plugins Unterstützung für die Entwicklung von Node.js Anwendungen</li>
                            <li>Mocha ist ein Node.js basiertes Testframework, das Unittests für JavaScript Anwendungen inklusive Node.js Anwendungen bietet</li>
                            <li>Sinon JS und Nock sind Mocking Bibliotheken, die für die Erstellung von JavaScript Unittests genutzt werden können</li>
                            <li>Istanbul ist ein Werkzeug um die Testabdeckung von JavaScript Programmen messen zu können</li>
                            <li>JSHint und JSCS ermöglichen die Codeanalyse von JavaScript Programmen, um potenzielle Fehler und schlechte Code Qualität aufzudecken</li>
                        </ul>
                    </aside>
                </section>

                <section>
                    <h2>Node.js in der Praxis</h2>
                    <h4>Anwendungsbereiche</h4>
                    <ul>
                        <li>Browsergames</li>
                        <li>REST APIs</li>
                        <li>Database APIs</li>
                        <li>IoT/Embedded</li>
                    </ul>

                    <aside class="notes">
                        Der klassische Einsatzbereich von Node.js ist natürlich die Bereitstellung von Webpages.
                        Daneben finden sich aber auch einige andere interessante Einsatzbereiche, in denen Node.js Verwendung finden kann.
                        <ul>
                            <li>Browsergames benötigen selten komplexe Berechnungen, oft aber Datenbankinteraktionen, schnelle Reaktionszeiten und eine hohe Anzahl gleichzeitiger Verbindungen</li>
                            <li>REST und Database APIs sind mit Node.js schnell und mit wenig Aufwand implementierbar</li>
                            <li>
                                Auch ungewöhnliche Anwendungsbereiche wie Embedded Geräte und Robotiksteuerung sind dank verschiedener Communityprojekte möglich.
                                Die Steuerung von Robotern und einfachen Rechnern wie dem Rapsberry Pi über Node.js bietet beispielsweise das Projekt Cylon.js
                            </li>
                        </ul>
                    </aside>
                </section>

                <section>
                    <h2>Node.js in der Praxis</h2>
                    <h4>Fallbeispiel: PayPal</h4>
                    <ul>
                        <li>Aufgabe: Neuimplementierung der Paypal Accountübersicht</li>
                        <li>Ziel: Auflösung des Bruchs zwischen Front- und Backend</li>
                        <li>Umsetzung mit Node.js</li>
                        <li>Backup: Parallele Entwicklung in JavaEE</li>
                    </ul>
                    <aside class="notes">
                        Das hier beschriebene Fallbeispiel ist dem folgenden Blogeintrag entnommen: https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/<br>
                        Um den Bruch zwischen Java Backend und JavaScript Frontend aufzulösen, wurde die Paypal Accountübersicht mit Node.js entwickelt.
                        Da noch keine Erfahrung mit Node.js Projekten vorhanden war, wurden die selben Funktionen parallel mit der bereits etablierten JavaEE Technologie implementiert, um
                        das Erreichen einer funktionsfähigen Lösung in jedem Fall sicherzustellen.
                    </aside>
                </section>

                <section>
                    <h2>Fallbeispiel: PayPal</h2>
                    <h4>Unterschiede Node.js - JavaEE Implementierung:</h4>
                    <ul>
                        <li class="fragment">Fast halbierte Entwicklungszeit trotz geringerer Entwicklerzahl</li>
                        <li class="fragment">33% weniger Lines of Code</li>
                        <li class="fragment">40% weniger Dateien</li>
                        <li class="fragment">Doppelte Requests pro Sekunde </li>
                        <li class="fragment">Durchschnittliche Antwortzeit 35% (200ms) reduziert</li>
                    </ul>
                    <aside class="notes">
                        Die Ergebnisse dieses Fallbeispiels zeigen eindrucksvoll die Vorteile von Node.js:
                        <ul>
                            <li>Schnelle Entwicklungszeiten dank der dynamischen Sprache JavaScript und wenig Konfigurationsaufwand</li>
                            <li>Effiziente und einfache Ausdrucksweise der Programmiersprache und des Frameworks führen zu weniger geschriebenem Code und dadurch zu weniger Fehlern und weniger Wartungsaufwand</li>
                            <li>Das eventgetriebene Design und die Nutzung der Event Loop bieten vor allem bei hohen Nutzerzahlen deutliche Performancevorteile</li>
                        </ul>
                    </aside>
                </section>

                <section>
                    <h3>Vielen Dank für die Aufmerksamkeit!</h3>
                    <br>
                    <br>
                    <h2>Fragen? / Diskussion</h2>
                </section>

                <section>
                    <h4>Quellen</h4>
                    <ul>
                        <li>Manuel Kiessling, <i>The Node Beginner Book</i></li>
                        <li>Jeff Harell, <i>Node.js at Paypal</i>, www.paypal-engineering.com/2013/11/22/node-js-at-paypal/</li>
                        <li><i>www.nodejs.org</i></li>
                        <li><i>www.nodecode.de</i></li>
                    </ul>
                </section>
            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                slideNumber: true,
                keyboard: true,
                overview: true,
                touch: true,
                embedded: false,
                transition: 'convex', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    {src: 'lib/js/classList.js', condition: function () {
                            return !document.body.classList;
                        }},
                    {src: 'plugin/markdown/marked.js', condition: function () {
                            return !!document.querySelector('[data-markdown]');
                        }},
                    {src: 'plugin/markdown/markdown.js', condition: function () {
                            return !!document.querySelector('[data-markdown]');
                        }},
//                    {src: 'plugin/highlight/highlight.js', async: true, condition: function () {
//                            return !!document.querySelector('pre code');
//                        }, callback: function () {
//                            hljs.initHighlightingOnLoad();
//                        }},
                    {src: 'plugin/zoom-js/zoom.js', async: true},
//                    {src: 'plugin/remotes/remotes.js', async: true},
                    {src: 'plugin/notes/notes.js', async: true}
                ]
            });

//            Reveal.addEventListener('slidechanged', function (event) {
//                // event.previousSlide, event.currentSlide, event.indexh, event.indexv
//                var notes = event.currentSlide.querySelector(".notes");
//                if (notes) {
//                    console.info(notes.innerHTML.replace(/\n\s+/g, '\n'));
//                }
//            });

        </script>

    </body>
</html>
